{"version":3,"sources":["webpack:///redux-cablecar.min.js","webpack:///webpack/bootstrap b6904ad04613b4af6137","webpack:///./index.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_middleware","_middleware2","middleware","_cableCar","_cableCar2","cableProvider","car","store","next","incomingAction","action","type","unsubscribe","channel","getState","unsubscribeAll","changeChannel","newChannel","params","allows","CableCar__Action","running","indexOf","send","optimistic","console","error","options","optimisticOnFail","connect","e","Error","CableCar","bind","getChannels","perform","subscribe","setProvider","newProvider","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","prototype","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_this","this","undefined","initialized","dispatch","connected","index","push","disconnected","pop","received","msg","rejected","actionCableProvider","defaultOptions","prefix","initialize","subscriptions","consumer","createConsumer","wsURL","_this2","create","newAction","matchPrefix","slice","keys","method","payload","_this3","forEach","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","context","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","WebSocket","window","logger","url","ref","getConfig","Consumer","createWebSocketURL","name","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","startDebugging","debugging","stopDebugging","log","messages","Date","now","apply","concat","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","interval","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","unsupportedProtocol","item","l","Connection","open","monitor","reopenDelay","data","webSocket","JSON","stringify","isActive","uninstallEventHandlers","installEventHandlers","close","arg","allowReconnect","ref1","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","identifier","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","channelName","mixin","subscription","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","findAll","len","results","s","args","callbackName","command","extend","object","properties","disconnect"],"mappings":"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","file":"redux-cablecar.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _middleware = __webpack_require__(1);\n\t\n\tvar _middleware2 = _interopRequireDefault(_middleware);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _middleware2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _cableCar = __webpack_require__(2);\n\t\n\tvar _cableCar2 = _interopRequireDefault(_cableCar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//import CableCarDispatcher from './cableCarDispatcher';\n\t\n\tvar cableProvider = void 0;\n\t\n\tvar car = void 0;\n\t\n\t//const dispatcher = new CableCarDispatcher();\n\t\n\tvar middleware = function middleware(store) {\n\t  return function (next) {\n\t    return function (incomingAction) {\n\t      var action = incomingAction;\n\t\n\t      switch (action.type) {\n\t\n\t        case 'CABLECAR_INITIALIZED':\n\t        case 'CABLECAR_CONNECTED':\n\t        case 'CABLECAR_DISCONNECTED':\n\t          return next(action);\n\t\n\t        case 'CABLECAR_DESTROY':\n\t          if (car) {\n\t            car.unsubscribe(action.channel);\n\t          }\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_DESTROY_ALL':\n\t          if (car) {\n\t            car.unsubscribeAll();\n\t          }\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_CHANGE_CHANNEL':\n\t          if (car) {\n\t            car.changeChannel(action.newChannel, action.params);\n\t          }\n\t          return next(action);\n\t\n\t        default:\n\t          if (car && car.allows(action) && action.channel && !action.CableCar__Action) {\n\t            if (car.running.indexOf(action.channel) > -1) {\n\t              car.send(action.channel, action);\n\t            } else {\n\t              // eslint-disable-next-line no-console\n\t              console.error('CableCar: Dropped action!', 'Attempting to dispatch an action but cable car is not running.', action, 'optimisticOnFail: ' + car.options.optimisticOnFail);\n\t              return car.options.optimisticOnFail ? next(action) : store.getState();\n\t            }\n\t            return action.optimistic ? next(action) : store.getState();\n\t          }\n\t          return next(action);\n\t      }\n\t    };\n\t  };\n\t};\n\t\n\tmiddleware.connect = function (store, options) {\n\t  if (!cableProvider) {\n\t    try {\n\t      // eslint-disable-next-line global-require\n\t      cableProvider = __webpack_require__(3);\n\t    } catch (e) {\n\t      throw new Error('CableCar: No actionCableProvider set and \\'actioncable\\' Node package failed to load: ' + e);\n\t    }\n\t  }\n\t\n\t  car = new _cableCar2.default(cableProvider, store, options);\n\t\n\t  // public car object returned\n\t  return {\n\t    changeChannel: car.changeChannel.bind(car),\n\t    getChannels: car.getChannels.bind(car),\n\t    perform: car.perform.bind(car),\n\t    send: car.send.bind(car),\n\t    unsubscribe: car.unsubscribe.bind(car),\n\t    subscribe: car.subscribe.bind(car)\n\t  };\n\t};\n\t\n\tmiddleware.setProvider = function (newProvider) {\n\t  cableProvider = newProvider;\n\t};\n\t\n\texports.default = middleware;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCar = function () {\n\t  function CableCar(cableProvider, store) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t    _classCallCheck(this, CableCar);\n\t\n\t    this.initialized = function (channel) {\n\t      return _this.dispatch({ type: 'CABLECAR_INITIALIZED', channel: channel });\n\t    };\n\t\n\t    this.connected = function (channel) {\n\t      _this.dispatch({ type: 'CABLECAR_CONNECTED', channel: channel });\n\t      var index = _this.running.indexOf(channel);\n\t      if (index === -1) {\n\t        _this.running.push(channel);\n\t      }\n\t      if (_this.options.connected) {\n\t        _this.options.connected.call(channel);\n\t      }\n\t    };\n\t\n\t    this.disconnected = function (channel) {\n\t      _this.dispatch({ type: 'CABLECAR_DISCONNECTED', channel: channel });\n\t      var index = _this.running.indexOf(channel);\n\t      if (index > -1) {\n\t        _this.running[index] = _this.running[_this.running.length - 1];\n\t        _this.running.pop();\n\t      }\n\t      if (_this.options.disconnected) {\n\t        _this.options.disconnected.call(channel);\n\t      }\n\t    };\n\t\n\t    this.received = function (msg, channel) {\n\t      _this.dispatch(_extends({}, msg, { channel: channel }));\n\t    };\n\t\n\t    this.rejected = function (channel) {\n\t      throw new Error('CableCar: Attempt to connect was rejected.\\n      (Channel: ' + channel + ')');\n\t    };\n\t\n\t    if (typeof cableProvider === 'undefined') {\n\t      throw new Error('CableCar: unknown ActionCable provider: ' + cableProvider);\n\t    }\n\t\n\t    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n\t      throw new Error('CableCar: unknown store: ' + store);\n\t    }\n\t\n\t    this.actionCableProvider = cableProvider;\n\t    this.store = store;\n\t\n\t    var defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n\t    this.initialize(Object.assign(defaultOptions, options));\n\t  }\n\t\n\t  _createClass(CableCar, [{\n\t    key: 'initialize',\n\t    value: function initialize(options) {\n\t      this.options = options;\n\t      this.running = [];\n\t      this.subscriptions = {};\n\t\n\t      this.consumer = this.actionCableProvider.createConsumer(options.wsURL);\n\t    }\n\t\n\t    // ActionCable callback functions\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(channel) {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      this.subscriptions[channel] = this.consumer.subscriptions.create(Object.assign({ channel: channel }, params), {\n\t        initialized: function initialized() {\n\t          return _this2.initialized(channel);\n\t        },\n\t        connected: function connected() {\n\t          return _this2.connected(channel);\n\t        },\n\t        disconnected: function disconnected() {\n\t          return _this2.disconnected(channel);\n\t        },\n\t        received: function received(msg) {\n\t          return _this2.received(msg, channel);\n\t        },\n\t        rejected: function rejected() {\n\t          return _this2.rejected(channel);\n\t        }\n\t      });\n\t    }\n\t\n\t    // Redux dispatch function\n\t\n\t  }, {\n\t    key: 'dispatch',\n\t    value: function dispatch(action) {\n\t      var newAction = Object.assign(action, {\n\t        CableCar__Action: true\n\t      });\n\t      this.store.dispatch(newAction);\n\t    }\n\t  }, {\n\t    key: 'allows',\n\t    value: function allows(action) {\n\t      if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) !== 'object' || typeof action.type !== 'string') {\n\t        throw new Error('CableCar: ' + action + ' is not a valid redux action ({ type: ... })');\n\t      }\n\t\n\t      return this.matchPrefix(action.type);\n\t    }\n\t  }, {\n\t    key: 'matchPrefix',\n\t    value: function matchPrefix(type) {\n\t      var prefix = type.slice(0, this.options.prefix.length);\n\t      return prefix === this.options.prefix;\n\t    }\n\t\n\t    // ActionCable subscription functions (exposed globally)\n\t\n\t  }, {\n\t    key: 'changeChannel',\n\t    value: function changeChannel(channel) {\n\t      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      if (this.subscriptions[channel]) {\n\t        this.unsubscribe(channel);\n\t        this.subscribe(channel, params);\n\t      } else {\n\t        throw new Error('CableCar: Unknown Channel ' + channel + ' to change Channel');\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getChannels',\n\t    value: function getChannels() {\n\t      return Object.keys(this.subscriptions);\n\t    }\n\t  }, {\n\t    key: 'perform',\n\t    value: function perform(channel, method, payload) {\n\t      if (this.subscriptions[channel]) {\n\t        this.subscriptions[channel].perform(method, payload);\n\t      } else {\n\t        throw new Error('CableCar: Unknown Channel ' + channel + ' to call perform ' + method);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(channel, action) {\n\t      if (this.subscriptions[channel]) {\n\t        this.subscriptions[channel].send(action);\n\t      } else {\n\t        throw new Error('CableCar: Unknown Channel ' + channel + ' to send ' + action.type);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(channel) {\n\t      if (this.subscriptions[channel]) {\n\t        this.subscriptions[channel].unsubscribe();\n\t        delete this.subscriptions[channel];\n\t        this.disconnected(channel);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'unsubscribeAll',\n\t    value: function unsubscribeAll() {\n\t      var _this3 = this;\n\t\n\t      Object.keys(this.subscriptions).forEach(function (channel) {\n\t        _this3.unsubscribe(channel);\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return CableCar;\n\t}();\n\t\n\texports.default = CableCar;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t  var context = this;\n\t\n\t  (function() {\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      this.ActionCable = {\n\t        INTERNAL: {\n\t          \"message_types\": {\n\t            \"welcome\": \"welcome\",\n\t            \"ping\": \"ping\",\n\t            \"confirmation\": \"confirm_subscription\",\n\t            \"rejection\": \"reject_subscription\"\n\t          },\n\t          \"default_mount_path\": \"/cable\",\n\t          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n\t        },\n\t        WebSocket: window.WebSocket,\n\t        logger: window.console,\n\t        createConsumer: function(url) {\n\t          var ref;\n\t          if (url == null) {\n\t            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n\t          }\n\t          return new ActionCable.Consumer(this.createWebSocketURL(url));\n\t        },\n\t        getConfig: function(name) {\n\t          var element;\n\t          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n\t          return element != null ? element.getAttribute(\"content\") : void 0;\n\t        },\n\t        createWebSocketURL: function(url) {\n\t          var a;\n\t          if (url && !/^wss?:/i.test(url)) {\n\t            a = document.createElement(\"a\");\n\t            a.href = url;\n\t            a.href = a.href;\n\t            a.protocol = a.protocol.replace(\"http\", \"ws\");\n\t            return a.href;\n\t          } else {\n\t            return url;\n\t          }\n\t        },\n\t        startDebugging: function() {\n\t          return this.debugging = true;\n\t        },\n\t        stopDebugging: function() {\n\t          return this.debugging = null;\n\t        },\n\t        log: function() {\n\t          var messages, ref;\n\t          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          if (this.debugging) {\n\t            messages.push(Date.now());\n\t            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n\t          }\n\t        }\n\t      };\n\t\n\t    }).call(this);\n\t  }).call(context);\n\t\n\t  var ActionCable = context.ActionCable;\n\t\n\t  (function() {\n\t    (function() {\n\t      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t      ActionCable.ConnectionMonitor = (function() {\n\t        var clamp, now, secondsSince;\n\t\n\t        ConnectionMonitor.pollInterval = {\n\t          min: 3,\n\t          max: 30\n\t        };\n\t\n\t        ConnectionMonitor.staleThreshold = 6;\n\t\n\t        function ConnectionMonitor(connection) {\n\t          this.connection = connection;\n\t          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n\t          this.reconnectAttempts = 0;\n\t        }\n\t\n\t        ConnectionMonitor.prototype.start = function() {\n\t          if (!this.isRunning()) {\n\t            this.startedAt = now();\n\t            delete this.stoppedAt;\n\t            this.startPolling();\n\t            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stop = function() {\n\t          if (this.isRunning()) {\n\t            this.stoppedAt = now();\n\t            this.stopPolling();\n\t            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor stopped\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.isRunning = function() {\n\t          return (this.startedAt != null) && (this.stoppedAt == null);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordPing = function() {\n\t          return this.pingedAt = now();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordConnect = function() {\n\t          this.reconnectAttempts = 0;\n\t          this.recordPing();\n\t          delete this.disconnectedAt;\n\t          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordDisconnect = function() {\n\t          this.disconnectedAt = now();\n\t          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.startPolling = function() {\n\t          this.stopPolling();\n\t          return this.poll();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stopPolling = function() {\n\t          return clearTimeout(this.pollTimeout);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.poll = function() {\n\t          return this.pollTimeout = setTimeout((function(_this) {\n\t            return function() {\n\t              _this.reconnectIfStale();\n\t              return _this.poll();\n\t            };\n\t          })(this), this.getPollInterval());\n\t        };\n\t\n\t        ConnectionMonitor.prototype.getPollInterval = function() {\n\t          var interval, max, min, ref;\n\t          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n\t          interval = 5 * Math.log(this.reconnectAttempts + 1);\n\t          return Math.round(clamp(interval, min, max) * 1000);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.reconnectIfStale = function() {\n\t          if (this.connectionIsStale()) {\n\t            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n\t            this.reconnectAttempts++;\n\t            if (this.disconnectedRecently()) {\n\t              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n\t            } else {\n\t              ActionCable.log(\"ConnectionMonitor reopening\");\n\t              return this.connection.reopen();\n\t            }\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.connectionIsStale = function() {\n\t          var ref;\n\t          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.disconnectedRecently = function() {\n\t          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.visibilityDidChange = function() {\n\t          if (document.visibilityState === \"visible\") {\n\t            return setTimeout((function(_this) {\n\t              return function() {\n\t                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n\t                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n\t                  return _this.connection.reopen();\n\t                }\n\t              };\n\t            })(this), 200);\n\t          }\n\t        };\n\t\n\t        now = function() {\n\t          return new Date().getTime();\n\t        };\n\t\n\t        secondsSince = function(time) {\n\t          return (now() - time) / 1000;\n\t        };\n\t\n\t        clamp = function(number, min, max) {\n\t          return Math.max(min, Math.min(max, number));\n\t        };\n\t\n\t        return ConnectionMonitor;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n\t        slice = [].slice,\n\t        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\t\n\t      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\t\n\t      ActionCable.Connection = (function() {\n\t        Connection.reopenDelay = 500;\n\t\n\t        function Connection(consumer) {\n\t          this.consumer = consumer;\n\t          this.open = bind(this.open, this);\n\t          this.subscriptions = this.consumer.subscriptions;\n\t          this.monitor = new ActionCable.ConnectionMonitor(this);\n\t          this.disconnected = true;\n\t        }\n\t\n\t        Connection.prototype.send = function(data) {\n\t          if (this.isOpen()) {\n\t            this.webSocket.send(JSON.stringify(data));\n\t            return true;\n\t          } else {\n\t            return false;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.open = function() {\n\t          if (this.isActive()) {\n\t            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n\t            return false;\n\t          } else {\n\t            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n\t            if (this.webSocket != null) {\n\t              this.uninstallEventHandlers();\n\t            }\n\t            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n\t            this.installEventHandlers();\n\t            this.monitor.start();\n\t            return true;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.close = function(arg) {\n\t          var allowReconnect, ref1;\n\t          allowReconnect = (arg != null ? arg : {\n\t            allowReconnect: true\n\t          }).allowReconnect;\n\t          if (!allowReconnect) {\n\t            this.monitor.stop();\n\t          }\n\t          if (this.isActive()) {\n\t            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.reopen = function() {\n\t          var error;\n\t          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n\t          if (this.isActive()) {\n\t            try {\n\t              return this.close();\n\t            } catch (error1) {\n\t              error = error1;\n\t              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n\t            } finally {\n\t              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n\t              setTimeout(this.open, this.constructor.reopenDelay);\n\t            }\n\t          } else {\n\t            return this.open();\n\t          }\n\t        };\n\t\n\t        Connection.prototype.getProtocol = function() {\n\t          var ref1;\n\t          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n\t        };\n\t\n\t        Connection.prototype.isOpen = function() {\n\t          return this.isState(\"open\");\n\t        };\n\t\n\t        Connection.prototype.isActive = function() {\n\t          return this.isState(\"open\", \"connecting\");\n\t        };\n\t\n\t        Connection.prototype.isProtocolSupported = function() {\n\t          var ref1;\n\t          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.isState = function() {\n\t          var ref1, states;\n\t          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.getState = function() {\n\t          var ref1, state, value;\n\t          for (state in WebSocket) {\n\t            value = WebSocket[state];\n\t            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n\t              return state.toLowerCase();\n\t            }\n\t          }\n\t          return null;\n\t        };\n\t\n\t        Connection.prototype.installEventHandlers = function() {\n\t          var eventName, handler;\n\t          for (eventName in this.events) {\n\t            handler = this.events[eventName].bind(this);\n\t            this.webSocket[\"on\" + eventName] = handler;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.uninstallEventHandlers = function() {\n\t          var eventName;\n\t          for (eventName in this.events) {\n\t            this.webSocket[\"on\" + eventName] = function() {};\n\t          }\n\t        };\n\t\n\t        Connection.prototype.events = {\n\t          message: function(event) {\n\t            var identifier, message, ref1, type;\n\t            if (!this.isProtocolSupported()) {\n\t              return;\n\t            }\n\t            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n\t            switch (type) {\n\t              case message_types.welcome:\n\t                this.monitor.recordConnect();\n\t                return this.subscriptions.reload();\n\t              case message_types.ping:\n\t                return this.monitor.recordPing();\n\t              case message_types.confirmation:\n\t                return this.subscriptions.notify(identifier, \"connected\");\n\t              case message_types.rejection:\n\t                return this.subscriptions.reject(identifier);\n\t              default:\n\t                return this.subscriptions.notify(identifier, \"received\", message);\n\t            }\n\t          },\n\t          open: function() {\n\t            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n\t            this.disconnected = false;\n\t            if (!this.isProtocolSupported()) {\n\t              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n\t              return this.close({\n\t                allowReconnect: false\n\t              });\n\t            }\n\t          },\n\t          close: function(event) {\n\t            ActionCable.log(\"WebSocket onclose event\");\n\t            if (this.disconnected) {\n\t              return;\n\t            }\n\t            this.disconnected = true;\n\t            this.monitor.recordDisconnect();\n\t            return this.subscriptions.notifyAll(\"disconnected\", {\n\t              willAttemptReconnect: this.monitor.isRunning()\n\t            });\n\t          },\n\t          error: function() {\n\t            return ActionCable.log(\"WebSocket onerror event\");\n\t          }\n\t        };\n\t\n\t        return Connection;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      ActionCable.Subscriptions = (function() {\n\t        function Subscriptions(consumer) {\n\t          this.consumer = consumer;\n\t          this.subscriptions = [];\n\t        }\n\t\n\t        Subscriptions.prototype.create = function(channelName, mixin) {\n\t          var channel, params, subscription;\n\t          channel = channelName;\n\t          params = typeof channel === \"object\" ? channel : {\n\t            channel: channel\n\t          };\n\t          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n\t          return this.add(subscription);\n\t        };\n\t\n\t        Subscriptions.prototype.add = function(subscription) {\n\t          this.subscriptions.push(subscription);\n\t          this.consumer.ensureActiveConnection();\n\t          this.notify(subscription, \"initialized\");\n\t          this.sendCommand(subscription, \"subscribe\");\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.remove = function(subscription) {\n\t          this.forget(subscription);\n\t          if (!this.findAll(subscription.identifier).length) {\n\t            this.sendCommand(subscription, \"unsubscribe\");\n\t          }\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.reject = function(identifier) {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.findAll(identifier);\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            this.forget(subscription);\n\t            this.notify(subscription, \"rejected\");\n\t            results.push(subscription);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.forget = function(subscription) {\n\t          var s;\n\t          this.subscriptions = (function() {\n\t            var i, len, ref, results;\n\t            ref = this.subscriptions;\n\t            results = [];\n\t            for (i = 0, len = ref.length; i < len; i++) {\n\t              s = ref[i];\n\t              if (s !== subscription) {\n\t                results.push(s);\n\t              }\n\t            }\n\t            return results;\n\t          }).call(this);\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.findAll = function(identifier) {\n\t          var i, len, ref, results, s;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            s = ref[i];\n\t            if (s.identifier === identifier) {\n\t              results.push(s);\n\t            }\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.reload = function() {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.sendCommand(subscription, \"subscribe\"));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notifyAll = function() {\n\t          var args, callbackName, i, len, ref, results, subscription;\n\t          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notify = function() {\n\t          var args, callbackName, i, len, results, subscription, subscriptions;\n\t          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\t          if (typeof subscription === \"string\") {\n\t            subscriptions = this.findAll(subscription);\n\t          } else {\n\t            subscriptions = [subscription];\n\t          }\n\t          results = [];\n\t          for (i = 0, len = subscriptions.length; i < len; i++) {\n\t            subscription = subscriptions[i];\n\t            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.sendCommand = function(subscription, command) {\n\t          var identifier;\n\t          identifier = subscription.identifier;\n\t          return this.consumer.send({\n\t            command: command,\n\t            identifier: identifier\n\t          });\n\t        };\n\t\n\t        return Subscriptions;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Subscription = (function() {\n\t        var extend;\n\t\n\t        function Subscription(consumer, params, mixin) {\n\t          this.consumer = consumer;\n\t          if (params == null) {\n\t            params = {};\n\t          }\n\t          this.identifier = JSON.stringify(params);\n\t          extend(this, mixin);\n\t        }\n\t\n\t        Subscription.prototype.perform = function(action, data) {\n\t          if (data == null) {\n\t            data = {};\n\t          }\n\t          data.action = action;\n\t          return this.send(data);\n\t        };\n\t\n\t        Subscription.prototype.send = function(data) {\n\t          return this.consumer.send({\n\t            command: \"message\",\n\t            identifier: this.identifier,\n\t            data: JSON.stringify(data)\n\t          });\n\t        };\n\t\n\t        Subscription.prototype.unsubscribe = function() {\n\t          return this.consumer.subscriptions.remove(this);\n\t        };\n\t\n\t        extend = function(object, properties) {\n\t          var key, value;\n\t          if (properties != null) {\n\t            for (key in properties) {\n\t              value = properties[key];\n\t              object[key] = value;\n\t            }\n\t          }\n\t          return object;\n\t        };\n\t\n\t        return Subscription;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Consumer = (function() {\n\t        function Consumer(url) {\n\t          this.url = url;\n\t          this.subscriptions = new ActionCable.Subscriptions(this);\n\t          this.connection = new ActionCable.Connection(this);\n\t        }\n\t\n\t        Consumer.prototype.send = function(data) {\n\t          return this.connection.send(data);\n\t        };\n\t\n\t        Consumer.prototype.connect = function() {\n\t          return this.connection.open();\n\t        };\n\t\n\t        Consumer.prototype.disconnect = function() {\n\t          return this.connection.close({\n\t            allowReconnect: false\n\t          });\n\t        };\n\t\n\t        Consumer.prototype.ensureActiveConnection = function() {\n\t          if (!this.connection.isActive()) {\n\t            return this.connection.open();\n\t          }\n\t        };\n\t\n\t        return Consumer;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  if (typeof module === \"object\" && module.exports) {\n\t    module.exports = ActionCable;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// redux-cablecar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b6904ad04613b4af6137","import middleware from './src/middleware';\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import CableCar from './cableCar';\n//import CableCarDispatcher from './cableCarDispatcher';\n\nlet cableProvider;\n\nlet car\n\n//const dispatcher = new CableCarDispatcher();\n\nconst middleware = store => next => (incomingAction) => {\n  const action = incomingAction;\n\n  switch (action.type) {\n\n    case 'CABLECAR_INITIALIZED':\n    case 'CABLECAR_CONNECTED':\n    case 'CABLECAR_DISCONNECTED':\n      return next(action);\n\n    case 'CABLECAR_DESTROY':\n      if (car) {\n        car.unsubscribe(action.channel);\n      }\n      return store.getState();\n\n    case 'CABLECAR_DESTROY_ALL':\n      if (car) {\n        car.unsubscribeAll();\n      }\n      return store.getState();\n\n    case 'CABLECAR_CHANGE_CHANNEL':\n      if (car) {\n        car.changeChannel(action.newChannel, action.params);\n      }\n      return next(action);\n\n    default:\n      if (car && car.allows(action) && action.channel && !action.CableCar__Action) {\n        if (car.running.indexOf(action.channel) > -1) {\n          car.send(action.channel, action);\n        } else {\n          // eslint-disable-next-line no-console\n          console.error('CableCar: Dropped action!',\n            'Attempting to dispatch an action but cable car is not running.',\n            action,\n            `optimisticOnFail: ${car.options.optimisticOnFail}`);\n          return car.options.optimisticOnFail ? next(action) : store.getState();\n        }\n        return action.optimistic ? next(action) : store.getState();\n      }\n      return next(action);\n  }\n};\n\nmiddleware.connect = (store, options) => {\n  if (!cableProvider) {\n    try {\n      // eslint-disable-next-line global-require\n      cableProvider = require('actioncable');\n    } catch (e) {\n      throw new Error(`CableCar: No actionCableProvider set and 'actioncable' Node package failed to load: ${e}`);\n    }\n  }\n\n  car = new CableCar(cableProvider, store, options);\n\n  // public car object returned\n  return {\n    changeChannel: car.changeChannel.bind(car),\n    getChannels: car.getChannels.bind(car),\n    perform: car.perform.bind(car),\n    send: car.send.bind(car),\n    unsubscribe: car.unsubscribe.bind(car),\n    subscribe: car.subscribe.bind(car)\n  };\n};\n\nmiddleware.setProvider = (newProvider) => {\n  cableProvider = newProvider;\n}\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","\nexport default class CableCar {\n  constructor(cableProvider, store, options = {}) {\n    if (typeof cableProvider === 'undefined') {\n      throw new Error(`CableCar: unknown ActionCable provider: ${cableProvider}`);\n    }\n\n    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n      throw new Error(`CableCar: unknown store: ${store}`);\n    }\n\n    this.actionCableProvider = cableProvider;\n    this.store = store;\n\n    const defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n    this.initialize(Object.assign(defaultOptions, options));\n  }\n\n  initialize(options) {\n    this.options = options;\n    this.running = [];\n    this.subscriptions = {};\n\n    this.consumer = this.actionCableProvider.createConsumer(options.wsURL);\n  }\n\n  // ActionCable callback functions\n  initialized = channel => this.dispatch({ type: 'CABLECAR_INITIALIZED', channel });\n\n  connected = (channel) => {\n    this.dispatch({ type: 'CABLECAR_CONNECTED', channel });\n    const index = this.running.indexOf(channel);\n    if (index === -1) {\n      this.running.push(channel);\n    }\n    if (this.options.connected) { this.options.connected.call(channel); }\n  }\n\n  disconnected = (channel) => {\n    this.dispatch({ type: 'CABLECAR_DISCONNECTED', channel });\n    const index = this.running.indexOf(channel);\n    if (index > -1) {\n      this.running[index] = this.running[this.running.length - 1];\n      this.running.pop();\n    }\n    if (this.options.disconnected) { this.options.disconnected.call(channel); }\n  }\n\n  received = (msg, channel) => {\n    this.dispatch({ ...msg, channel });\n  }\n\n  rejected = (channel) => {\n    throw new Error(\n      `CableCar: Attempt to connect was rejected.\n      (Channel: ${channel})`,\n    );\n  }\n\n  subscribe(channel, params = {}) {\n    this.subscriptions[channel] = this.consumer.subscriptions.create(\n      Object.assign({ channel }, params), {\n        initialized: () => this.initialized(channel),\n        connected: () => this.connected(channel),\n        disconnected: () => this.disconnected(channel),\n        received: msg => this.received(msg, channel),\n        rejected: () => this.rejected(channel),\n      },\n    );\n  }\n\n  // Redux dispatch function\n  dispatch(action) {\n    const newAction = Object.assign(action, {\n      CableCar__Action: true,\n    });\n    this.store.dispatch(newAction);\n  }\n\n  allows(action) {\n    if (typeof action !== 'object' || typeof action.type !== 'string') {\n      throw new Error(`CableCar: ${action} is not a valid redux action ({ type: ... })`);\n    }\n\n    return this.matchPrefix(action.type);\n  }\n\n  matchPrefix(type) {\n    const prefix = type.slice(0, this.options.prefix.length);\n    return prefix === this.options.prefix;\n  }\n\n  // ActionCable subscription functions (exposed globally)\n  changeChannel(channel, params = {}) {\n    if (this.subscriptions[channel]) {\n      this.unsubscribe(channel);\n      this.subscribe(channel, params);\n    } else {\n      throw new Error(`CableCar: Unknown Channel ${channel} to change Channel`);\n    }\n  }\n\n  getChannels() {\n    return Object.keys(this.subscriptions);\n  }\n\n  perform(channel, method, payload) {\n    if (this.subscriptions[channel]) {\n      this.subscriptions[channel].perform(method, payload);\n    } else {\n      throw new Error(`CableCar: Unknown Channel ${channel} to call perform ${method}`)\n    }\n  }\n\n  send(channel, action) {\n    if (this.subscriptions[channel]) {\n      this.subscriptions[channel].send(action);\n    } else {\n      throw new Error(`CableCar: Unknown Channel ${channel} to send ${action.type}`)\n    }\n  }\n\n  unsubscribe(channel) {\n    if (this.subscriptions[channel]) {\n      this.subscriptions[channel].unsubscribe();\n      delete this.subscriptions[channel];\n      this.disconnected(channel);\n    }\n  }\n\n  unsubscribeAll() {\n    Object.keys(this.subscriptions).forEach((channel) => {\n      this.unsubscribe(channel);\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","(function() {\n  var context = this;\n\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(context);\n\n  var ActionCable = context.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}