{"version":3,"sources":["webpack:///redux-cablecar.min.js","webpack:///webpack/bootstrap 19ff63ee2ff73e3f4a38","webpack:///./index.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_middleware","_middleware2","middleware","_cableCar","_cableCar2","cableProvider","car","store","next","incomingAction","action","type","unsubscribe","CableCarChannel","getState","unsubscribeAll","changeChannel","newChannel","params","allows","CableCar__Action","running","send","channel","optimistic","console","error","options","optimisticOnFail","connect","e","Error","CableCar","bind","getChannels","perform","subscribe","setProvider","newProvider","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","prototype","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_this","this","undefined","initialized","dispatch","connected","disconnected","received","msg","rejected","actionCableProvider","defaultOptions","prefix","initialize","subscriptions","consumer","createConsumer","wsURL","_this2","create","newAction","matchPrefix","slice","keys","method","payload","_this3","forEach","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","context","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","WebSocket","window","logger","url","ref","getConfig","Consumer","createWebSocketURL","name","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","startDebugging","debugging","stopDebugging","log","messages","push","Date","now","apply","concat","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","interval","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","unsupportedProtocol","indexOf","item","l","Connection","open","monitor","reopenDelay","data","webSocket","JSON","stringify","isActive","uninstallEventHandlers","installEventHandlers","close","arg","allowReconnect","ref1","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","identifier","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","channelName","mixin","subscription","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","findAll","len","results","s","args","callbackName","command","extend","object","properties","disconnect"],"mappings":"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","file":"redux-cablecar.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _middleware = __webpack_require__(1);\n\t\n\tvar _middleware2 = _interopRequireDefault(_middleware);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _middleware2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _cableCar = __webpack_require__(2);\n\t\n\tvar _cableCar2 = _interopRequireDefault(_cableCar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//import CableCarDispatcher from './cableCarDispatcher';\n\t\n\tvar cableProvider = void 0;\n\t\n\tvar car = void 0;\n\t\n\t//const dispatcher = new CableCarDispatcher();\n\t\n\tvar middleware = function middleware(store) {\n\t  return function (next) {\n\t    return function (incomingAction) {\n\t      var action = incomingAction;\n\t\n\t      switch (action.type) {\n\t\n\t        case 'CABLECAR_INITIALIZED':\n\t        case 'CABLECAR_CONNECTED':\n\t        case 'CABLECAR_DISCONNECTED':\n\t          return next(action);\n\t\n\t        case 'CABLECAR_DESTROY':\n\t          if (car) {\n\t            car.unsubscribe(action.CableCarChannel);\n\t          }\n\t\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_DESTROY_ALL':\n\t          if (car) {\n\t            car.unsubscribeAll();\n\t          }\n\t\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_CHANGE_CHANNEL':\n\t          if (car) {\n\t            car.changeChannel(action.newChannel, action.params);\n\t          }\n\t\n\t          return store.getState();\n\t\n\t        default:\n\t          if (car && car.allows(action) && !action.CableCar__Action) {\n\t            if (car.running) {\n\t              car.send(action.channel, action);\n\t            } else {\n\t              console.error('CableCar: Dropped action!', 'Attempting to dispatch an action but cable car is not running.', action, 'optimisticOnFail: ' + car.options.optimisticOnFail);\n\t              return car.options.optimisticOnFail ? next(action) : store.getState();\n\t            }\n\t            return action.optimistic ? next(action) : store.getState();\n\t          } else {\n\t            return next(action);\n\t          }\n\t      }\n\t    };\n\t  };\n\t};\n\t\n\tmiddleware.connect = function (store, options) {\n\t  if (!cableProvider) {\n\t    try {\n\t      cableProvider = __webpack_require__(3);\n\t    } catch (e) {\n\t      throw new Error('CableCar: No actionCableProvider set and \\'actioncable\\' Node package failed to load: ' + e);\n\t    }\n\t  }\n\t\n\t  car = new _cableCar2.default(cableProvider, store, options);\n\t\n\t  // public car object returned\n\t  return {\n\t    changeChannel: car.changeChannel.bind(car),\n\t    getChannels: car.getChannels.bind(car),\n\t    perform: car.perform.bind(car),\n\t    send: car.send.bind(car),\n\t    unsubscribe: car.unsubscribe.bind(car),\n\t    subscribe: car.subscribe.bind(car)\n\t  };\n\t};\n\t\n\tmiddleware.setProvider = function (newProvider) {\n\t  cableProvider = newProvider;\n\t};\n\t\n\texports.default = middleware;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCar = function () {\n\t  function CableCar(cableProvider, store) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t    _classCallCheck(this, CableCar);\n\t\n\t    this.initialized = function (channel) {\n\t      return _this.dispatch({ type: 'CABLECAR_INITIALIZED', channel: channel });\n\t    };\n\t\n\t    this.connected = function (channel) {\n\t      _this.dispatch({ type: 'CABLECAR_CONNECTED', channel: channel });\n\t      _this.running = true;\n\t      if (_this.options.connected) {\n\t        _this.options.connected.call(channel);\n\t      }\n\t    };\n\t\n\t    this.disconnected = function (channel) {\n\t      _this.dispatch({ type: 'CABLECAR_DISCONNECTED', channel: channel });\n\t      _this.running = false;\n\t      if (_this.options.disconnected) {\n\t        _this.options.disconnected.call(channel);\n\t      }\n\t    };\n\t\n\t    this.received = function (msg, channel) {\n\t      _this.dispatch(_extends({}, msg, { channel: channel }));\n\t    };\n\t\n\t    this.rejected = function (channel) {\n\t      throw new Error('CableCar: Attempt to connect was rejected.\\n      (Channel: ' + channel + ')');\n\t    };\n\t\n\t    if (typeof cableProvider === 'undefined') {\n\t      throw new Error('CableCar: unknown ActionCable provider: ' + cableProvider);\n\t    }\n\t\n\t    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n\t      throw new Error('CableCar: unknown store: ' + store);\n\t    }\n\t\n\t    this.actionCableProvider = cableProvider;\n\t    this.store = store;\n\t\n\t    var defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n\t    this.initialize(Object.assign(defaultOptions, options));\n\t  }\n\t\n\t  _createClass(CableCar, [{\n\t    key: 'initialize',\n\t    value: function initialize(options) {\n\t\n\t      this.options = options;\n\t      this.running = false;\n\t      this.subscriptions = {};\n\t\n\t      this.consumer = this.actionCableProvider.createConsumer(options.wsURL);\n\t    }\n\t\n\t    // ActionCable callback functions\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(channel) {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      this.subscriptions[channel] = this.consumer.subscriptions.create(Object.assign({ channel: channel }, params), {\n\t        initialized: function initialized() {\n\t          return _this2.initialized(channel);\n\t        },\n\t        connected: function connected() {\n\t          return _this2.connected(channel);\n\t        },\n\t        disconnected: function disconnected() {\n\t          return _this2.disconnected(channel);\n\t        },\n\t        received: function received(msg) {\n\t          return _this2.received(msg, channel);\n\t        },\n\t        rejected: function rejected() {\n\t          return _this2.rejected(channel);\n\t        }\n\t      });\n\t    }\n\t\n\t    // Redux dispatch function\n\t\n\t  }, {\n\t    key: 'dispatch',\n\t    value: function dispatch(action) {\n\t      var newAction = Object.assign(action, {\n\t        CableCar__Action: true\n\t      });\n\t      this.store.dispatch(newAction);\n\t    }\n\t  }, {\n\t    key: 'allows',\n\t    value: function allows(action) {\n\t      if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) !== 'object' || typeof action.type !== 'string') {\n\t        throw new Error('CableCar: ' + action + ' is not a valid redux action ({ type: ... })');\n\t      }\n\t\n\t      return this.matchPrefix(action.type);\n\t    }\n\t  }, {\n\t    key: 'matchPrefix',\n\t    value: function matchPrefix(type) {\n\t      var prefix = type.slice(0, this.options.prefix.length);\n\t      return prefix === this.options.prefix;\n\t    }\n\t\n\t    // ActionCable subscription functions (exposed globally)\n\t\n\t  }, {\n\t    key: 'changeChannel',\n\t    value: function changeChannel(channel) {\n\t      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      if (this.subscriptions[channel]) {\n\t        this.unsubscribe(channel);\n\t        this.subscribe(channel, params);\n\t      } else {\n\t        throw new Error('CableCar: Unknown Channel ' + channel + ' to change Channel');\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getChannels',\n\t    value: function getChannels() {\n\t      return Object.keys(this.subscriptions);\n\t    }\n\t  }, {\n\t    key: 'perform',\n\t    value: function perform(channel, method, payload) {\n\t      if (this.subscriptions[channel]) {\n\t        this.subscriptions[channel].perform(method, payload);\n\t      } else {\n\t        throw new Error('CableCar: Unknown Channel ' + channel + ' to call perform ' + method);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(channel, action) {\n\t      if (this.subscriptions[channel]) {\n\t        this.subscriptions[channel].send(action);\n\t      } else {\n\t        throw new Error('CableCar: Unknown Channel ' + channel + ' to send ' + action.type);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(channel) {\n\t      if (this.subscriptions[channel]) {\n\t        this.subscriptions[channel].unsubscribe();\n\t        this.disconnected(channel);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'unsubscribeAll',\n\t    value: function unsubscribeAll() {\n\t      var _this3 = this;\n\t\n\t      Object.keys(this.subscriptions).forEach(function (channel) {\n\t        _this3.unsubscribe(channel);\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return CableCar;\n\t}();\n\t\n\texports.default = CableCar;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t  var context = this;\n\t\n\t  (function() {\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      this.ActionCable = {\n\t        INTERNAL: {\n\t          \"message_types\": {\n\t            \"welcome\": \"welcome\",\n\t            \"ping\": \"ping\",\n\t            \"confirmation\": \"confirm_subscription\",\n\t            \"rejection\": \"reject_subscription\"\n\t          },\n\t          \"default_mount_path\": \"/cable\",\n\t          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n\t        },\n\t        WebSocket: window.WebSocket,\n\t        logger: window.console,\n\t        createConsumer: function(url) {\n\t          var ref;\n\t          if (url == null) {\n\t            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n\t          }\n\t          return new ActionCable.Consumer(this.createWebSocketURL(url));\n\t        },\n\t        getConfig: function(name) {\n\t          var element;\n\t          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n\t          return element != null ? element.getAttribute(\"content\") : void 0;\n\t        },\n\t        createWebSocketURL: function(url) {\n\t          var a;\n\t          if (url && !/^wss?:/i.test(url)) {\n\t            a = document.createElement(\"a\");\n\t            a.href = url;\n\t            a.href = a.href;\n\t            a.protocol = a.protocol.replace(\"http\", \"ws\");\n\t            return a.href;\n\t          } else {\n\t            return url;\n\t          }\n\t        },\n\t        startDebugging: function() {\n\t          return this.debugging = true;\n\t        },\n\t        stopDebugging: function() {\n\t          return this.debugging = null;\n\t        },\n\t        log: function() {\n\t          var messages, ref;\n\t          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          if (this.debugging) {\n\t            messages.push(Date.now());\n\t            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n\t          }\n\t        }\n\t      };\n\t\n\t    }).call(this);\n\t  }).call(context);\n\t\n\t  var ActionCable = context.ActionCable;\n\t\n\t  (function() {\n\t    (function() {\n\t      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t      ActionCable.ConnectionMonitor = (function() {\n\t        var clamp, now, secondsSince;\n\t\n\t        ConnectionMonitor.pollInterval = {\n\t          min: 3,\n\t          max: 30\n\t        };\n\t\n\t        ConnectionMonitor.staleThreshold = 6;\n\t\n\t        function ConnectionMonitor(connection) {\n\t          this.connection = connection;\n\t          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n\t          this.reconnectAttempts = 0;\n\t        }\n\t\n\t        ConnectionMonitor.prototype.start = function() {\n\t          if (!this.isRunning()) {\n\t            this.startedAt = now();\n\t            delete this.stoppedAt;\n\t            this.startPolling();\n\t            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stop = function() {\n\t          if (this.isRunning()) {\n\t            this.stoppedAt = now();\n\t            this.stopPolling();\n\t            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor stopped\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.isRunning = function() {\n\t          return (this.startedAt != null) && (this.stoppedAt == null);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordPing = function() {\n\t          return this.pingedAt = now();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordConnect = function() {\n\t          this.reconnectAttempts = 0;\n\t          this.recordPing();\n\t          delete this.disconnectedAt;\n\t          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordDisconnect = function() {\n\t          this.disconnectedAt = now();\n\t          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.startPolling = function() {\n\t          this.stopPolling();\n\t          return this.poll();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stopPolling = function() {\n\t          return clearTimeout(this.pollTimeout);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.poll = function() {\n\t          return this.pollTimeout = setTimeout((function(_this) {\n\t            return function() {\n\t              _this.reconnectIfStale();\n\t              return _this.poll();\n\t            };\n\t          })(this), this.getPollInterval());\n\t        };\n\t\n\t        ConnectionMonitor.prototype.getPollInterval = function() {\n\t          var interval, max, min, ref;\n\t          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n\t          interval = 5 * Math.log(this.reconnectAttempts + 1);\n\t          return Math.round(clamp(interval, min, max) * 1000);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.reconnectIfStale = function() {\n\t          if (this.connectionIsStale()) {\n\t            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n\t            this.reconnectAttempts++;\n\t            if (this.disconnectedRecently()) {\n\t              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n\t            } else {\n\t              ActionCable.log(\"ConnectionMonitor reopening\");\n\t              return this.connection.reopen();\n\t            }\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.connectionIsStale = function() {\n\t          var ref;\n\t          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.disconnectedRecently = function() {\n\t          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.visibilityDidChange = function() {\n\t          if (document.visibilityState === \"visible\") {\n\t            return setTimeout((function(_this) {\n\t              return function() {\n\t                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n\t                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n\t                  return _this.connection.reopen();\n\t                }\n\t              };\n\t            })(this), 200);\n\t          }\n\t        };\n\t\n\t        now = function() {\n\t          return new Date().getTime();\n\t        };\n\t\n\t        secondsSince = function(time) {\n\t          return (now() - time) / 1000;\n\t        };\n\t\n\t        clamp = function(number, min, max) {\n\t          return Math.max(min, Math.min(max, number));\n\t        };\n\t\n\t        return ConnectionMonitor;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n\t        slice = [].slice,\n\t        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\t\n\t      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\t\n\t      ActionCable.Connection = (function() {\n\t        Connection.reopenDelay = 500;\n\t\n\t        function Connection(consumer) {\n\t          this.consumer = consumer;\n\t          this.open = bind(this.open, this);\n\t          this.subscriptions = this.consumer.subscriptions;\n\t          this.monitor = new ActionCable.ConnectionMonitor(this);\n\t          this.disconnected = true;\n\t        }\n\t\n\t        Connection.prototype.send = function(data) {\n\t          if (this.isOpen()) {\n\t            this.webSocket.send(JSON.stringify(data));\n\t            return true;\n\t          } else {\n\t            return false;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.open = function() {\n\t          if (this.isActive()) {\n\t            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n\t            return false;\n\t          } else {\n\t            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n\t            if (this.webSocket != null) {\n\t              this.uninstallEventHandlers();\n\t            }\n\t            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n\t            this.installEventHandlers();\n\t            this.monitor.start();\n\t            return true;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.close = function(arg) {\n\t          var allowReconnect, ref1;\n\t          allowReconnect = (arg != null ? arg : {\n\t            allowReconnect: true\n\t          }).allowReconnect;\n\t          if (!allowReconnect) {\n\t            this.monitor.stop();\n\t          }\n\t          if (this.isActive()) {\n\t            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.reopen = function() {\n\t          var error;\n\t          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n\t          if (this.isActive()) {\n\t            try {\n\t              return this.close();\n\t            } catch (error1) {\n\t              error = error1;\n\t              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n\t            } finally {\n\t              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n\t              setTimeout(this.open, this.constructor.reopenDelay);\n\t            }\n\t          } else {\n\t            return this.open();\n\t          }\n\t        };\n\t\n\t        Connection.prototype.getProtocol = function() {\n\t          var ref1;\n\t          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n\t        };\n\t\n\t        Connection.prototype.isOpen = function() {\n\t          return this.isState(\"open\");\n\t        };\n\t\n\t        Connection.prototype.isActive = function() {\n\t          return this.isState(\"open\", \"connecting\");\n\t        };\n\t\n\t        Connection.prototype.isProtocolSupported = function() {\n\t          var ref1;\n\t          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.isState = function() {\n\t          var ref1, states;\n\t          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.getState = function() {\n\t          var ref1, state, value;\n\t          for (state in WebSocket) {\n\t            value = WebSocket[state];\n\t            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n\t              return state.toLowerCase();\n\t            }\n\t          }\n\t          return null;\n\t        };\n\t\n\t        Connection.prototype.installEventHandlers = function() {\n\t          var eventName, handler;\n\t          for (eventName in this.events) {\n\t            handler = this.events[eventName].bind(this);\n\t            this.webSocket[\"on\" + eventName] = handler;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.uninstallEventHandlers = function() {\n\t          var eventName;\n\t          for (eventName in this.events) {\n\t            this.webSocket[\"on\" + eventName] = function() {};\n\t          }\n\t        };\n\t\n\t        Connection.prototype.events = {\n\t          message: function(event) {\n\t            var identifier, message, ref1, type;\n\t            if (!this.isProtocolSupported()) {\n\t              return;\n\t            }\n\t            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n\t            switch (type) {\n\t              case message_types.welcome:\n\t                this.monitor.recordConnect();\n\t                return this.subscriptions.reload();\n\t              case message_types.ping:\n\t                return this.monitor.recordPing();\n\t              case message_types.confirmation:\n\t                return this.subscriptions.notify(identifier, \"connected\");\n\t              case message_types.rejection:\n\t                return this.subscriptions.reject(identifier);\n\t              default:\n\t                return this.subscriptions.notify(identifier, \"received\", message);\n\t            }\n\t          },\n\t          open: function() {\n\t            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n\t            this.disconnected = false;\n\t            if (!this.isProtocolSupported()) {\n\t              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n\t              return this.close({\n\t                allowReconnect: false\n\t              });\n\t            }\n\t          },\n\t          close: function(event) {\n\t            ActionCable.log(\"WebSocket onclose event\");\n\t            if (this.disconnected) {\n\t              return;\n\t            }\n\t            this.disconnected = true;\n\t            this.monitor.recordDisconnect();\n\t            return this.subscriptions.notifyAll(\"disconnected\", {\n\t              willAttemptReconnect: this.monitor.isRunning()\n\t            });\n\t          },\n\t          error: function() {\n\t            return ActionCable.log(\"WebSocket onerror event\");\n\t          }\n\t        };\n\t\n\t        return Connection;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      ActionCable.Subscriptions = (function() {\n\t        function Subscriptions(consumer) {\n\t          this.consumer = consumer;\n\t          this.subscriptions = [];\n\t        }\n\t\n\t        Subscriptions.prototype.create = function(channelName, mixin) {\n\t          var channel, params, subscription;\n\t          channel = channelName;\n\t          params = typeof channel === \"object\" ? channel : {\n\t            channel: channel\n\t          };\n\t          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n\t          return this.add(subscription);\n\t        };\n\t\n\t        Subscriptions.prototype.add = function(subscription) {\n\t          this.subscriptions.push(subscription);\n\t          this.consumer.ensureActiveConnection();\n\t          this.notify(subscription, \"initialized\");\n\t          this.sendCommand(subscription, \"subscribe\");\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.remove = function(subscription) {\n\t          this.forget(subscription);\n\t          if (!this.findAll(subscription.identifier).length) {\n\t            this.sendCommand(subscription, \"unsubscribe\");\n\t          }\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.reject = function(identifier) {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.findAll(identifier);\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            this.forget(subscription);\n\t            this.notify(subscription, \"rejected\");\n\t            results.push(subscription);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.forget = function(subscription) {\n\t          var s;\n\t          this.subscriptions = (function() {\n\t            var i, len, ref, results;\n\t            ref = this.subscriptions;\n\t            results = [];\n\t            for (i = 0, len = ref.length; i < len; i++) {\n\t              s = ref[i];\n\t              if (s !== subscription) {\n\t                results.push(s);\n\t              }\n\t            }\n\t            return results;\n\t          }).call(this);\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.findAll = function(identifier) {\n\t          var i, len, ref, results, s;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            s = ref[i];\n\t            if (s.identifier === identifier) {\n\t              results.push(s);\n\t            }\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.reload = function() {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.sendCommand(subscription, \"subscribe\"));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notifyAll = function() {\n\t          var args, callbackName, i, len, ref, results, subscription;\n\t          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notify = function() {\n\t          var args, callbackName, i, len, results, subscription, subscriptions;\n\t          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\t          if (typeof subscription === \"string\") {\n\t            subscriptions = this.findAll(subscription);\n\t          } else {\n\t            subscriptions = [subscription];\n\t          }\n\t          results = [];\n\t          for (i = 0, len = subscriptions.length; i < len; i++) {\n\t            subscription = subscriptions[i];\n\t            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.sendCommand = function(subscription, command) {\n\t          var identifier;\n\t          identifier = subscription.identifier;\n\t          return this.consumer.send({\n\t            command: command,\n\t            identifier: identifier\n\t          });\n\t        };\n\t\n\t        return Subscriptions;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Subscription = (function() {\n\t        var extend;\n\t\n\t        function Subscription(consumer, params, mixin) {\n\t          this.consumer = consumer;\n\t          if (params == null) {\n\t            params = {};\n\t          }\n\t          this.identifier = JSON.stringify(params);\n\t          extend(this, mixin);\n\t        }\n\t\n\t        Subscription.prototype.perform = function(action, data) {\n\t          if (data == null) {\n\t            data = {};\n\t          }\n\t          data.action = action;\n\t          return this.send(data);\n\t        };\n\t\n\t        Subscription.prototype.send = function(data) {\n\t          return this.consumer.send({\n\t            command: \"message\",\n\t            identifier: this.identifier,\n\t            data: JSON.stringify(data)\n\t          });\n\t        };\n\t\n\t        Subscription.prototype.unsubscribe = function() {\n\t          return this.consumer.subscriptions.remove(this);\n\t        };\n\t\n\t        extend = function(object, properties) {\n\t          var key, value;\n\t          if (properties != null) {\n\t            for (key in properties) {\n\t              value = properties[key];\n\t              object[key] = value;\n\t            }\n\t          }\n\t          return object;\n\t        };\n\t\n\t        return Subscription;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Consumer = (function() {\n\t        function Consumer(url) {\n\t          this.url = url;\n\t          this.subscriptions = new ActionCable.Subscriptions(this);\n\t          this.connection = new ActionCable.Connection(this);\n\t        }\n\t\n\t        Consumer.prototype.send = function(data) {\n\t          return this.connection.send(data);\n\t        };\n\t\n\t        Consumer.prototype.connect = function() {\n\t          return this.connection.open();\n\t        };\n\t\n\t        Consumer.prototype.disconnect = function() {\n\t          return this.connection.close({\n\t            allowReconnect: false\n\t          });\n\t        };\n\t\n\t        Consumer.prototype.ensureActiveConnection = function() {\n\t          if (!this.connection.isActive()) {\n\t            return this.connection.open();\n\t          }\n\t        };\n\t\n\t        return Consumer;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  if (typeof module === \"object\" && module.exports) {\n\t    module.exports = ActionCable;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// redux-cablecar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 19ff63ee2ff73e3f4a38","import middleware from './src/middleware';\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import CableCar from './cableCar';\n//import CableCarDispatcher from './cableCarDispatcher';\n\nlet cableProvider;\n\nlet car\n\n//const dispatcher = new CableCarDispatcher();\n\nconst middleware = store => next => (incomingAction) => {\n  const action = incomingAction;\n\n  switch (action.type) {\n\n    case 'CABLECAR_INITIALIZED':\n    case 'CABLECAR_CONNECTED':\n    case 'CABLECAR_DISCONNECTED':\n      return next(action);\n\n    case 'CABLECAR_DESTROY':\n      if (car) {\n        car.unsubscribe(action.CableCarChannel);\n      }\n      \n      return store.getState();\n\n    case 'CABLECAR_DESTROY_ALL':\n      if (car) {\n        car.unsubscribeAll()\n      }\n      \n      return store.getState();\n\n    case 'CABLECAR_CHANGE_CHANNEL':\n      if (car) {\n        car.changeChannel(action.newChannel, action.params)\n      }\n      \n      return store.getState();\n\n    default:\n      if (car && car.allows(action) && !action.CableCar__Action) {\n        if (car.running) {\n          car.send(action.channel, action);\n        } else {\n          console.error('CableCar: Dropped action!',\n            'Attempting to dispatch an action but cable car is not running.',\n            action,\n            'optimisticOnFail: ' + car.options.optimisticOnFail\n          );\n          return car.options.optimisticOnFail ? next(action) : store.getState();\n        }\n        return action.optimistic ? next(action) : store.getState();\n      } else {\n        return next(action);\n      }\n  }\n};\n\nmiddleware.connect = (store, options) => {\n  if (!cableProvider) {\n    try {\n      cableProvider = require('actioncable');\n    } catch(e) {\n      throw new Error(`CableCar: No actionCableProvider set and 'actioncable' Node package failed to load: ${e}`);\n    }\n  }\n\n  car = new CableCar(cableProvider, store, options);\n\n  // public car object returned\n  return {\n    changeChannel: car.changeChannel.bind(car),\n    getChannels: car.getChannels.bind(car),\n    perform: car.perform.bind(car),\n    send: car.send.bind(car),\n    unsubscribe: car.unsubscribe.bind(car),\n    subscribe: car.subscribe.bind(car)\n  };\n}\n\nmiddleware.setProvider = (newProvider) => {\n  cableProvider = newProvider;\n}\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","\nexport default class CableCar {\n\n  constructor(cableProvider, store, options = {}) {\n    if (typeof cableProvider === 'undefined') {\n      throw new Error(`CableCar: unknown ActionCable provider: ${cableProvider}`);\n    }\n\n    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n      throw new Error(`CableCar: unknown store: ${store}`);\n    }\n\n    this.actionCableProvider = cableProvider;\n    this.store = store;\n\n    const defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n    this.initialize(Object.assign(defaultOptions, options));\n  }\n\n  initialize(options) {\n\n\n    this.options = options;\n    this.running = false;\n    this.subscriptions = {}\n\n    this.consumer = this.actionCableProvider.createConsumer(options.wsURL);\n  }\n\n  // ActionCable callback functions\n  initialized = (channel) => this.dispatch({ type: 'CABLECAR_INITIALIZED', channel });\n\n  connected = (channel) => {\n    this.dispatch({ type: 'CABLECAR_CONNECTED', channel });\n    this.running = true;\n    if (this.options.connected) { this.options.connected.call(channel); }\n  }\n\n  disconnected = (channel) => {\n    this.dispatch({ type: 'CABLECAR_DISCONNECTED', channel });\n    this.running = false;\n    if (this.options.disconnected) { this.options.disconnected.call(channel); }\n  }\n\n  received = (msg, channel) => {\n    this.dispatch({ ...msg, channel });\n  }\n\n  rejected = (channel) => {\n    throw new Error(\n      `CableCar: Attempt to connect was rejected.\n      (Channel: ${channel})`,\n    );\n  }\n\n  subscribe (channel, params = {}) {\n    this.subscriptions[channel] = this.consumer.subscriptions.create(Object.assign({ channel }, params), {\n      initialized: () => this.initialized(channel),\n      connected: () => this.connected(channel),\n      disconnected: () => this.disconnected(channel),\n      received: (msg) => this.received(msg, channel),\n      rejected: () => this.rejected(channel),\n    })\n  }\n\n  // Redux dispatch function\n  dispatch(action) {\n    const newAction = Object.assign(action, {\n      CableCar__Action: true,\n    });\n    this.store.dispatch(newAction);\n  }\n\n  allows(action) {\n    if (typeof action !== 'object' || typeof action.type !== 'string') {\n      throw new Error(`CableCar: ${action} is not a valid redux action ({ type: ... })`);\n    }\n\n    return this.matchPrefix(action.type);\n  }\n\n  matchPrefix(type) {\n    const prefix = type.slice(0, this.options.prefix.length);\n    return prefix === this.options.prefix;\n  }\n\n  // ActionCable subscription functions (exposed globally)\n  changeChannel(channel, params = {}) {\n    if (this.subscriptions[channel]) {\n      this.unsubscribe(channel);\n      this.subscribe(channel, params);\n    }  else {\n      throw new Error(`CableCar: Unknown Channel ${channel} to change Channel`)\n    }\n  }\n\n  getChannels() {\n    return Object.keys(this.subscriptions);\n  }\n\n  perform(channel, method, payload) {\n    if (this.subscriptions[channel]) {\n      this.subscriptions[channel].perform(method, payload);\n    } else {\n      throw new Error(`CableCar: Unknown Channel ${channel} to call perform ${method}`)\n    }\n  }\n\n  send(channel, action) {\n    if (this.subscriptions[channel]) {\n      this.subscriptions[channel].send(action);\n    } else {\n      throw new Error(`CableCar: Unknown Channel ${channel} to send ${action.type}`)\n    }\n  }\n\n  unsubscribe(channel) {\n    if (this.subscriptions[channel]) {\n      this.subscriptions[channel].unsubscribe();\n      this.disconnected(channel);\n    }\n  }\n\n  unsubscribeAll () {\n    Object.keys(this.subscriptions).forEach(channel => {\n      this.unsubscribe(channel)\n    })\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","(function() {\n  var context = this;\n\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(context);\n\n  var ActionCable = context.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}